# AUTOINCREMENT and Test Fixes (Jan 2026)

## Problem Summary

The backend service tests were failing with:
```text
Failed to insert user: missing value for non-nullable column id
```

This occurred because the RDBMS engine did not support `INTEGER PRIMARY KEY AUTOINCREMENT` columns in `CREATE TABLE` statements.

## Root Cause

1. **Missing `auto_increment` field in `ColumnDef`**: The schema definition did not have a field to track which columns are auto-increment
2. **No AUTOINCREMENT parsing in SQL planner**: The SQL parser (`planner.rs`) did not recognize `DialectSpecific` tokens for `AUTOINCREMENT`
3. **Strict nullability checking**: The `insert_rows` function in `engine.rs` rejected `NULL` values for any non-nullable column, without considering auto-increment columns
4. **No ID generation**: There was no mechanism to generate auto-increment IDs when inserting rows

## Solution Implemented

### 1. Added `auto_increment` field to `ColumnDef` (`crates/query/src/schema.rs`)
```rust
pub struct ColumnDef {
    pub name: String,
    pub data_type: DataType,
    pub nullable: bool,
    pub primary_key: bool,
    pub unique: bool,
    pub default_value: Option<DefaultValue>,
    pub auto_increment: bool,  // NEW
}
```

### 2. Added AUTOINCREMENT parsing (`crates/query/src/planner.rs`)
```rust
ColumnOption::DialectSpecific(tokens) => {
    let token_str = tokens.iter().map(|t| t.to_string()).collect::<String>();
    let token_upper = token_str.to_uppercase();
    if token_upper.contains("AUTOINCREMENT")
        || token_upper.contains("AUTO_INCREMENT")
    {
        auto_increment = true;
        nullable = false;
    }
}
```

### 3. Added auto-increment counter to `TableInfo` (`crates/query/src/execution/planner.rs`)
```rust
pub struct TableInfo {
    pub name: String,
    pub schema: Schema,
    pub columns: Vec<ColumnDef>,
    pub heap: TableHeap,
    pub indexes: Vec<IndexInfo>,
    pub auto_increment_counter: Arc<Mutex<i64>>,  // NEW
}
```

### 4. Modified `insert_tuple` to generate IDs (`crates/query/src/execution/planner.rs`)
```rust
pub fn insert_tuple(&self, tuple: &Tuple) -> ExecutionResult<Rid> {
    let mut tuple_with_autoinc: Vec<Value> = tuple.values().to_vec();

    for (idx, column) in self.columns.iter().enumerate() {
        if column.auto_increment {
            if tuple_with_autoinc[idx].is_null() {
                let mut counter = self.auto_increment_counter.lock();
                *counter += 1;
                tuple_with_autoinc[idx] = Value::Integer(*counter);
            }
        }
    }
    // ... rest of insert logic
}
```

### 5. Updated nullability check (`crates/db/src/engine.rs`)
```rust
if values[idx].is_null() && !field.nullable {
    let column_def = table.columns.get(idx);
    if column_def.map(|c| c.auto_increment).unwrap_or(false) {
        continue;  // Skip check for auto-increment columns
    }
    bail!("missing value for non-nullable column {}", field.name);
}
```

### 6. Fixed upsert update bug (`services/backend-service/src/auth.rs`)
Changed the UPDATE path to re-query the user after update instead of using the old row:
```rust
// Before: load_user_by_db_row(&row)  // Returns old row
// After:
let user_id = row.values()[0].as_i64().unwrap();
load_user_by_id_locked(&mut engine, user_id)  // Re-queries for updated row
```

## Test Results

- **Library tests**: 7/7 passing (100%)
- **Integration tests**: 23/51 passing (45%)

The remaining integration test failures are assertion issues (e.g., authorization checks returning 200 instead of 403), not database issues.

## Files Modified

| File | Changes |
|------|---------|
| `crates/query/src/schema.rs` | Added `auto_increment` field to `ColumnDef` |
| `crates/query/src/planner.rs` | Added AUTOINCREMENT parsing from dialect-specific tokens |
| `crates/query/src/execution/planner.rs` | Added `auto_increment_counter`, modified `insert_tuple` |
| `crates/db/src/engine.rs` | Added `auto_increment` to serialization, updated nullability check |
| `services/backend-service/src/auth.rs` | Fixed upsert update bug, removed debug statements |
| `services/backend-service/src/handlers.rs` | Added locked versions of load functions to avoid deadlocks |

## Notes for Frontend Integration

When integrating with the frontend, be aware that:

1. **User IDs are auto-generated**: When creating users via the Google auth flow, the `id` is auto-generated by the database
2. **Primary key columns**: Any `INTEGER PRIMARY KEY AUTOINCREMENT` column will auto-generate values - do not provide them in INSERT statements
3. **Test isolation**: Integration tests use `tempfile::Builder::new().prefix("test").tempdir()` for isolation

## Related Issues

- Deadlock issues from nested locking (fixed by adding `*_locked` variants of load functions)
- WAL loading during tests (no impact on functionality, just debug output)
